diff -Nur a/cmake/modules/FindAW.cmake b/cmake/modules/FindAW.cmake
--- a/cmake/modules/FindAW.cmake	1970-01-01 01:00:00.000000000 +0100
+++ b/cmake/modules/FindAW.cmake	2018-04-08 17:46:06.511297230 +0200
@@ -0,0 +1,14 @@
+#.rst:
+# FindAW
+# -------
+# Finds the AW lib
+#
+# This will will define the following variables::
+#
+# AW_FOUND - system has AW
+# AW_LIBRARIES - the AW libraries
+# AW_DEFINITIONS - the AW definitions
+
+if(PKG_CONFIG_FOUND)
+  set(AW_FOUND TRUE)
+endif()
diff -Nur a/cmake/platform/linux/aw.cmake b/cmake/platform/linux/aw.cmake
--- a/cmake/platform/linux/aw.cmake	1970-01-01 01:00:00.000000000 +0100
+++ b/cmake/platform/linux/aw.cmake	2018-04-08 17:34:58.644438375 +0200
@@ -0,0 +1,3 @@
+set(PLATFORM_REQUIRED_DEPS OpenGLES AW EGL)
+set(APP_RENDER_SYSTEM gles)
+list(APPEND PLATFORM_DEFINES -DMESA_EGL_NO_X11_HEADERS)
diff -Nur a/cmake/treedata/optional/common/aw.txt b/cmake/treedata/optional/common/aw.txt
--- a/cmake/treedata/optional/common/aw.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/cmake/treedata/optional/common/aw.txt	2018-04-08 18:22:33.335394349 +0200
@@ -0,0 +1 @@
+xbmc/windowing/aw windowing/aw # AW
diff -Nur a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
--- a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt	2018-04-01 00:19:02.000000000 +0200
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt	2018-04-08 16:51:35.940813254 +0200
@@ -47,6 +47,7 @@
                        CORE_PLATFORM_NAME_LC STREQUAL aml OR
                        CORE_PLATFORM_NAME_LC STREQUAL gbm OR
                        CORE_PLATFORM_NAME_LC STREQUAL mir OR
+                       CORE_PLATFORM_NAME_LC STREQUAL aw OR
                        CORE_PLATFORM_NAME_LC STREQUAL wayland))
   list(APPEND SOURCES LinuxRendererGLES.cpp
                       FrameBufferObject.cpp)
diff -Nur a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt
--- a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt	2018-04-01 00:19:02.000000000 +0200
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/CMakeLists.txt	2018-04-08 16:52:19.357471323 +0200
@@ -27,6 +27,7 @@
                        CORE_PLATFORM_NAME_LC STREQUAL aml OR
                        CORE_PLATFORM_NAME_LC STREQUAL gbm OR
                        CORE_PLATFORM_NAME_LC STREQUAL mir OR
+                       CORE_PLATFORM_NAME_LC STREQUAL aw OR
                        CORE_PLATFORM_NAME_LC STREQUAL wayland))
   list(APPEND SOURCES VideoFilterShaderGLES.cpp
                       YUVMatrix.cpp
diff -Nur a/xbmc/platform/linux/input/CMakeLists.txt b/xbmc/platform/linux/input/CMakeLists.txt
--- a/xbmc/platform/linux/input/CMakeLists.txt	2018-04-01 00:19:02.000000000 +0200
+++ b/xbmc/platform/linux/input/CMakeLists.txt	2018-04-08 16:50:14.448581243 +0200
@@ -6,7 +6,7 @@
   list(APPEND HEADERS LIRC.h)
 endif()
 
-if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR CORE_PLATFORM_NAME_LC STREQUAL aml)
+if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR CORE_PLATFORM_NAME_LC STREQUAL aml OR CORE_PLATFORM_NAME_LC STREQUAL aw)
   list(APPEND SOURCES LinuxInputDevices.cpp)
   list(APPEND HEADERS LinuxInputDevices.h)
 endif()
diff -Nur a/xbmc/windowing/aw/CMakeLists.txt b/xbmc/windowing/aw/CMakeLists.txt
--- a/xbmc/windowing/aw/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/CMakeLists.txt	2018-04-08 16:56:19.246124131 +0200
@@ -0,0 +1,12 @@
+set(SOURCES WinSystemAllwinner.cpp
+            VideoSyncAW.cpp)
+
+set(HEADERS WinSystemAllwinner.h
+            VideoSyncAW.h)
+
+if(OPENGLES_FOUND)
+  list(APPEND SOURCES WinSystemAllwinnerGLESContext.cpp)
+  list(APPEND HEADERS WinSystemAllwinnerGLESContext.h)
+endif()
+
+core_add_library(windowing_Allwinner)
diff -Nur a/xbmc/windowing/aw/VideoSyncAW.cpp b/xbmc/windowing/aw/VideoSyncAW.cpp
--- a/xbmc/windowing/aw/VideoSyncAW.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/VideoSyncAW.cpp	2018-04-08 17:02:17.920741487 +0200
@@ -0,0 +1,103 @@
+/*
+ *      Copyright (C) 2017 Team XBMC
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "VideoSyncAW.h"
+#include "ServiceBroker.h"
+#include "guilib/GraphicContext.h"
+#include "utils/TimeUtils.h"
+#include "utils/log.h"
+#include "threads/Thread.h"
+#include "windowing/WinSystem.h"
+#include <sys/poll.h>
+
+#include <chrono>
+#include <thread>
+
+CVideoSyncAW::CVideoSyncAW(void *clock)
+: CVideoSync(clock)
+, m_abort(false)
+{
+}
+
+CVideoSyncAW::~CVideoSyncAW()
+{
+}
+
+bool CVideoSyncAW::Setup(PUPDATECLOCK func)
+{
+  UpdateClock = func;
+
+  m_abort = false;
+
+  CServiceBroker::GetWinSystem().Register(this);
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: setting up AW");
+
+  return true;
+}
+
+void CVideoSyncAW::Run(CEvent& stopEvent)
+{
+  // We use the wall clock for timout handling (no AW h/w, startup)
+  std::chrono::time_point<std::chrono::system_clock> now(std::chrono::system_clock::now());
+  unsigned int waittime (3000 / m_fps);
+  uint64_t numVBlanks (0);
+
+  while (!stopEvent.Signaled() && !m_abort)
+  {
+    int countVSyncs(1);
+    if( /*!g_AW_sync_event.WaitMSec(waittime)*/ 1)
+    {
+      std::chrono::milliseconds elapsed(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count());
+      uint64_t curVBlanks = (m_fps * elapsed.count()) / 1000;
+      int64_t lastVBlankTime((curVBlanks * 1000) / m_fps);
+      if (elapsed.count() > lastVBlankTime)
+      {
+        lastVBlankTime = (++curVBlanks * 1000) / m_fps;
+        std::this_thread::sleep_for(std::chrono::milliseconds(lastVBlankTime - elapsed.count()));
+      }
+      countVSyncs = curVBlanks - numVBlanks;
+      numVBlanks = curVBlanks;
+    }
+    else
+      ++numVBlanks;
+
+    uint64_t now = CurrentHostCounter();
+
+    UpdateClock(countVSyncs, now, m_refClock);
+  }
+}
+
+void CVideoSyncAW::Cleanup()
+{
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: cleaning up AW");
+  CServiceBroker::GetWinSystem().Unregister(this);
+}
+
+float CVideoSyncAW::GetFps()
+{
+  m_fps = g_graphicsContext.GetFPS();
+  CLog::Log(LOGDEBUG, "CVideoReferenceClock: fps: %.3f", m_fps);
+  return m_fps;
+}
+
+void CVideoSyncAW::OnResetDisplay()
+{
+  m_abort = true;
+}
diff -Nur a/xbmc/windowing/aw/VideoSyncAW.h b/xbmc/windowing/aw/VideoSyncAW.h
--- a/xbmc/windowing/aw/VideoSyncAW.h	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/VideoSyncAW.h	2018-04-08 16:59:25.932981429 +0200
@@ -0,0 +1,37 @@
+#pragma once
+/*
+ *      Copyright (C) 2017 Team XBMC
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "windowing/VideoSync.h"
+#include "guilib/DispResource.h"
+
+class CVideoSyncAW : public CVideoSync, IDispResource
+{
+public:
+  CVideoSyncAW(void *clock);
+  virtual ~CVideoSyncAW();
+  virtual bool Setup(PUPDATECLOCK func)override;
+  virtual void Run(CEvent& stopEvent)override;
+  virtual void Cleanup()override;
+  virtual float GetFps()override;
+  virtual void OnResetDisplay()override;
+private:
+  volatile bool m_abort;
+};
diff -Nur a/xbmc/windowing/aw/WinSystemAllwinner.cpp b/xbmc/windowing/aw/WinSystemAllwinner.cpp
--- a/xbmc/windowing/aw/WinSystemAllwinner.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/WinSystemAllwinner.cpp	2018-04-08 18:55:23.722551805 +0200
@@ -0,0 +1,357 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "WinSystemAllwinner.h"
+
+#include <string.h>
+#include <float.h>
+
+#include "ServiceBroker.h"
+#include "cores/RetroPlayer/rendering/VideoRenderers/RPRendererOpenGLES.h"
+#include "cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.h"
+// AESink Factory
+#include "cores/AudioEngine/AESinkFactory.h"
+#include "cores/AudioEngine/Sinks/AESinkALSA.h"
+#include "cores/AudioEngine/Sinks/AESinkPULSE.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/Resolution.h"
+#include "powermanagement/linux/LinuxPowerSyscall.h"
+#include "settings/Settings.h"
+#include "settings/DisplaySettings.h"
+#include "guilib/DispResource.h"
+#include "utils/log.h"
+#include "utils/SysfsUtils.h"
+#include "threads/SingleLock.h"
+#include "../WinEventsLinux.h"
+#include "utils/RegExp.h"
+#include "utils/StringUtils.h"
+
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+
+#include <FBDEV/eglplatform.h>
+#include <FBDEV/egl.h>
+#include <FBDEV/mali_fbdev_types.h>
+
+using namespace KODI;
+
+CWinSystemAllwinner::CWinSystemAllwinner()
+{
+  const char *env_framebuffer = getenv("FRAMEBUFFER");
+
+  // default to framebuffer 0
+  m_framebuffer_name = "fb0";
+  if (env_framebuffer)
+  {
+    std::string framebuffer(env_framebuffer);
+    std::string::size_type start = framebuffer.find("fb");
+    m_framebuffer_name = framebuffer.substr(start);
+  }
+
+  m_nativeDisplay = EGL_NO_DISPLAY;
+  m_nativeWindow = static_cast<EGLNativeWindowType>(NULL);
+
+  m_displayWidth = 0;
+  m_displayHeight = 0;
+
+  m_stereo_mode = RENDER_STEREO_MODE_OFF;
+  m_delayDispReset = false;
+
+  m_winEvents.reset(new CWinEventsLinux());
+  // Register sink
+  AE::CAESinkFactory::ClearSinks();
+  CAESinkALSA::Register();
+  CAESinkPULSE::Register();
+  CLinuxPowerSyscall::Register();
+}
+
+CWinSystemAllwinner::~CWinSystemAllwinner()
+{
+  if(m_nativeWindow)
+  {
+    m_nativeWindow = static_cast<EGLNativeWindowType>(NULL);
+  }
+}
+
+bool CWinSystemAllwinner::InitWindowSystem()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+
+  CLinuxRendererGLES::Register();
+
+  return CWinSystemBase::InitWindowSystem();
+}
+
+bool CWinSystemAllwinner::DestroyWindowSystem()
+{
+  return true;
+}
+
+bool CWinSystemAllwinner::CreateNewWindow(const std::string& name,
+                                    bool fullScreen,
+                                    RESOLUTION_INFO& res)
+{
+  RESOLUTION_INFO current_resolution;
+  current_resolution.iWidth = current_resolution.iHeight = 0;
+
+  m_nWidth        = res.iWidth;
+  m_nHeight       = res.iHeight;
+  m_displayWidth  = res.iScreenWidth;
+  m_displayHeight = res.iScreenHeight;
+  m_fRefreshRate  = res.fRefreshRate;
+
+  /*if ((m_bWindowCreated && aml_get_native_resolution(&current_resolution)) &&
+    current_resolution.iWidth == res.iWidth && current_resolution.iHeight == res.iHeight &&
+    current_resolution.iScreenWidth == res.iScreenWidth && current_resolution.iScreenHeight == res.iScreenHeight &&
+    m_bFullScreen == fullScreen && current_resolution.fRefreshRate == res.fRefreshRate &&
+    (current_resolution.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+    m_stereo_mode == stereo_mode)
+  {
+    CLog::Log(LOGDEBUG, "CWinSystemEGL::CreateNewWindow: No need to create a new window");
+    return true;
+  }*/
+
+  int delay = CServiceBroker::GetSettings().GetInt("videoscreen.delayrefreshchange");
+  if (delay > 0)
+  {
+    m_delayDispReset = true;
+    m_dispResetTimer.Set(delay * 100);
+  }
+
+  {
+    CSingleLock lock(m_resourceSection);
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+    {
+      (*i)->OnLostDisplay();
+    }
+  }
+
+  m_bFullScreen = fullScreen;
+
+  fbdev_window *nativeWindow = new fbdev_window;
+  nativeWindow->width = res.iWidth;
+  nativeWindow->height = res.iHeight;
+  m_nativeWindow = static_cast<EGLNativeWindowType>(nativeWindow);
+
+  SetFramebufferResolution(nativeWindow->width, nativeWindow->height);
+
+  if (!m_delayDispReset)
+  {
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+    {
+      (*i)->OnResetDisplay();
+    }
+  }
+
+  return true;
+}
+
+bool CWinSystemAllwinner::DestroyWindow()
+{
+  m_nativeWindow = static_cast<EGLNativeWindowType>(NULL);
+
+  return true;
+}
+
+static bool RockchipModeToResolution(std::string mode, RESOLUTION_INFO *res)
+{
+  if (!res)
+    return false;
+
+  res->iWidth = 0;
+  res->iHeight= 0;
+
+  if (mode.empty())
+    return false;
+
+  std::string fromMode = mode;
+  if (!isdigit(mode[0]))
+    fromMode = StringUtils::Mid(mode, 2);
+  StringUtils::Trim(fromMode);
+
+  CRegExp split(true);
+  split.RegComp("([0-9]+)x([0-9]+)([pi])-([0-9]+)");
+  if (split.RegFind(fromMode) < 0)
+    return false;
+
+  int w = atoi(split.GetMatch(1).c_str());
+  int h = atoi(split.GetMatch(2).c_str());
+  std::string p = split.GetMatch(3);
+  int r = atoi(split.GetMatch(4).c_str());
+
+  res->iWidth = w;
+  res->iHeight= h;
+  res->iScreenWidth = w;
+  res->iScreenHeight= h;
+  res->fRefreshRate = r;
+  res->dwFlags = p[0] == 'p' ? D3DPRESENTFLAG_PROGRESSIVE : D3DPRESENTFLAG_INTERLACED;
+
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->strMode       = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+                                           res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  res->strId         = mode;
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
+
+bool CWinSystemAllwinner::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  std::string mode;
+  SysfsUtils::GetString("/sys/class/drm/card0/device/graphics/" + m_framebuffer_name + "/mode", mode);
+  return RockchipModeToResolution(mode, res);
+}
+
+void CWinSystemAllwinner::UpdateResolutions()
+{
+  CWinSystemBase::UpdateResolutions();
+
+  std::vector<RESOLUTION_INFO> resolutions;
+  RESOLUTION_INFO resDesktop, curDisplay;
+
+  std::string valstr;
+  if (SysfsUtils::GetString("/sys/class/drm/card0/device/graphics/" + m_framebuffer_name + "/modes", valstr) < 0)
+    return;
+  std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+
+  RESOLUTION_INFO res;
+  for (std::vector<std::string>::const_iterator i = probe_str.begin(); i != probe_str.end(); ++i)
+  {
+    if (RockchipModeToResolution(i->c_str(), &res))
+      resolutions.push_back(res);
+  }
+
+  /* ProbeResolutions includes already all resolutions.
+   * Only get desktop resolution so we can replace xbmc's desktop res
+   */
+  if (GetNativeResolution(&curDisplay))
+  {
+	  resDesktop = curDisplay;
+  }
+
+  RESOLUTION ResDesktop = RES_INVALID;
+  RESOLUTION res_index  = RES_DESKTOP;
+
+  for (size_t i = 0; i < resolutions.size(); i++)
+  {
+    // if this is a new setting,
+    // create a new empty setting to fill in.
+    if ((int)CDisplaySettings::GetInstance().ResolutionInfoSize() <= res_index)
+    {
+      RESOLUTION_INFO res;
+      CDisplaySettings::GetInstance().AddResolutionInfo(res);
+    }
+
+    g_graphicsContext.ResetOverscan(resolutions[i]);
+    CDisplaySettings::GetInstance().GetResolutionInfo(res_index) = resolutions[i];
+
+    CLog::Log(LOGNOTICE, "Found resolution %d x %d for display %d with %d x %d%s @ %f Hz\n",
+      resolutions[i].iWidth,
+      resolutions[i].iHeight,
+      resolutions[i].iScreen,
+      resolutions[i].iScreenWidth,
+      resolutions[i].iScreenHeight,
+      resolutions[i].dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
+      resolutions[i].fRefreshRate);
+
+    if(resDesktop.iWidth == resolutions[i].iWidth &&
+       resDesktop.iHeight == resolutions[i].iHeight &&
+       resDesktop.iScreenWidth == resolutions[i].iScreenWidth &&
+       resDesktop.iScreenHeight == resolutions[i].iScreenHeight &&
+       (resDesktop.dwFlags & D3DPRESENTFLAG_MODEMASK) == (resolutions[i].dwFlags & D3DPRESENTFLAG_MODEMASK) &&
+       fabs(resDesktop.fRefreshRate - resolutions[i].fRefreshRate) < FLT_EPSILON)
+    {
+      ResDesktop = res_index;
+    }
+
+    res_index = (RESOLUTION)((int)res_index + 1);
+  }
+
+  // swap desktop index for desktop res if available
+  if (ResDesktop != RES_INVALID)
+  {
+    CLog::Log(LOGNOTICE, "Found (%dx%d%s@%f) at %d, setting to RES_DESKTOP at %d",
+      resDesktop.iWidth, resDesktop.iHeight,
+      resDesktop.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
+      resDesktop.fRefreshRate,
+      (int)ResDesktop, (int)RES_DESKTOP);
+
+    RESOLUTION_INFO desktop = CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP);
+    CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop);
+    CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop) = desktop;
+  }
+}
+
+void CWinSystemAllwinner::SetFramebufferResolution(const RESOLUTION_INFO &res) const
+{
+  SetFramebufferResolution(res.iScreenWidth, res.iScreenHeight);
+}
+
+void CWinSystemAllwinner::SetFramebufferResolution(int width, int height) const
+{
+  int fd0;
+  std::string framebuffer = "/dev/" + m_framebuffer_name;
+
+  if ((fd0 = open(framebuffer.c_str(), O_RDWR)) >= 0)
+  {
+    struct fb_var_screeninfo vinfo;
+    if (ioctl(fd0, FBIOGET_VSCREENINFO, &vinfo) == 0)
+    {
+      vinfo.xres = width;
+      vinfo.yres = height;
+      vinfo.xres_virtual = width;
+      vinfo.yres_virtual = height;
+      vinfo.bits_per_pixel = 32;
+      vinfo.activate = FB_ACTIVATE_ALL;
+      ioctl(fd0, FBIOPUT_VSCREENINFO, &vinfo);
+    }
+    close(fd0);
+  }
+}
+
+bool CWinSystemAllwinner::Hide()
+{
+  return false;
+}
+
+bool CWinSystemAllwinner::Show(bool show)
+{
+  std::string blank_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/blank";
+  SysfsUtils::SetInt(blank_framebuffer.c_str(), show ? 0 : 1);
+  return true;
+}
+
+void CWinSystemAllwinner::Register(IDispResource *resource)
+{
+  CSingleLock lock(m_resourceSection);
+  m_resources.push_back(resource);
+}
+
+void CWinSystemAllwinner::Unregister(IDispResource *resource)
+{
+  CSingleLock lock(m_resourceSection);
+  std::vector<IDispResource*>::iterator i = find(m_resources.begin(), m_resources.end(), resource);
+  if (i != m_resources.end())
+    m_resources.erase(i);
+}
diff -Nur a/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.cpp b/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.cpp
--- a/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.cpp	2018-04-08 17:04:48.799547436 +0200
@@ -0,0 +1,165 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "VideoSyncAW.h"
+#include "WinSystemAllwinnerGLESContext.h"
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+
+std::unique_ptr<CWinSystemBase> CWinSystemBase::CreateWinSystem()
+{
+  std::unique_ptr<CWinSystemBase> winSystem(new CWinSystemAllwinnerGLESContext());
+  return winSystem;
+}
+
+bool CWinSystemAllwinnerGLESContext::InitWindowSystem()
+{
+  if (!CWinSystemAllwinner::InitWindowSystem())
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.CreateDisplay(m_nativeDisplay,
+                                  EGL_OPENGL_ES2_BIT,
+                                  EGL_OPENGL_ES_API))
+  {
+    return false;
+  }
+
+  return true;
+}
+
+bool CWinSystemAllwinnerGLESContext::CreateNewWindow(const std::string& name,
+                                               bool fullScreen,
+                                               RESOLUTION_INFO& res)
+{
+  m_pGLContext.Detach();
+
+  if (!CWinSystemAllwinner::DestroyWindow())
+  {
+    return false;
+  }
+
+  if (!CWinSystemAllwinner::CreateNewWindow(name, fullScreen, res))
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.CreateSurface(m_nativeWindow))
+  {
+    return false;
+  }
+
+  const EGLint contextAttribs[] =
+  {
+    EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE
+  };
+
+  if (!m_pGLContext.CreateContext(contextAttribs))
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.BindContext())
+  {
+    return false;
+  }
+
+  if (!m_pGLContext.SurfaceAttrib())
+  {
+    return false;
+  }
+
+  if (!m_delayDispReset)
+  {
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDisplay();
+  }
+
+  return true;
+}
+
+bool CWinSystemAllwinnerGLESContext::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
+{
+  CRenderSystemGLES::ResetRenderSystem(newWidth, newHeight);
+  return true;
+}
+
+bool CWinSystemAllwinnerGLESContext::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
+{
+  CreateNewWindow("", fullScreen, res);
+  CRenderSystemGLES::ResetRenderSystem(res.iWidth, res.iHeight);
+  return true;
+}
+
+void CWinSystemAllwinnerGLESContext::SetVSyncImpl(bool enable)
+{
+  m_iVSyncMode = enable ? 10:0;
+  if (!m_pGLContext.SetVSync(enable))
+  {
+    m_iVSyncMode = 0;
+    CLog::Log(LOGERROR, "%s,Could not set egl vsync", __FUNCTION__);
+  }
+}
+
+void CWinSystemAllwinnerGLESContext::PresentRenderImpl(bool rendered)
+{
+  if (m_delayDispReset && m_dispResetTimer.IsTimePast())
+  {
+    m_delayDispReset = false;
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (std::vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); ++i)
+      (*i)->OnResetDisplay();
+  }
+  if (!rendered)
+    return;
+
+  m_pGLContext.SwapBuffers();
+}
+
+EGLDisplay CWinSystemAllwinnerGLESContext::GetEGLDisplay() const
+{
+  return m_pGLContext.m_eglDisplay;
+}
+
+EGLSurface CWinSystemAllwinnerGLESContext::GetEGLSurface() const
+{
+  return m_pGLContext.m_eglSurface;
+}
+
+EGLContext CWinSystemAllwinnerGLESContext::GetEGLContext() const
+{
+  return m_pGLContext.m_eglContext;
+}
+
+EGLConfig  CWinSystemAllwinnerGLESContext::GetEGLConfig() const
+{
+  return m_pGLContext.m_eglConfig;
+}
+
+std::unique_ptr<CVideoSync> CWinSystemAllwinnerGLESContext::GetVideoSync(void *clock)
+{
+  std::unique_ptr<CVideoSync> pVSync(new CVideoSyncAW(clock));
+  return pVSync;
+}
+
diff -Nur a/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.h b/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.h
--- a/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.h	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/WinSystemAllwinnerGLESContext.h	2018-04-08 17:03:12.821776698 +0200
@@ -0,0 +1,60 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "utils/EGLUtils.h"
+#include "rendering/gles/RenderSystemGLES.h"
+#include "utils/GlobalsHandling.h"
+#include "WinSystemAllwinner.h"
+
+class CWinSystemAllwinnerGLESContext : public CWinSystemAllwinner, public CRenderSystemGLES
+{
+public:
+  CWinSystemAllwinnerGLESContext() = default;
+  virtual ~CWinSystemAllwinnerGLESContext() = default;
+
+  // Implementation of CWinSystemBase via CWinSystemAllwinner
+  CRenderSystemBase *GetRenderSystem() override { return this; }
+  bool InitWindowSystem() override;
+  bool CreateNewWindow(const std::string& name,
+                       bool fullScreen,
+                       RESOLUTION_INFO& res) override;
+
+  bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
+  bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
+
+  virtual std::unique_ptr<CVideoSync> GetVideoSync(void *clock) override;
+
+  EGLDisplay GetEGLDisplay() const;
+  EGLSurface GetEGLSurface() const;
+  EGLContext GetEGLContext() const;
+  EGLConfig  GetEGLConfig() const;
+protected:
+  void SetVSyncImpl(bool enable) override;
+  void PresentRenderImpl(bool rendered) override;
+
+private:
+  CEGLContextUtils m_pGLContext;
+
+};
+
+XBMC_GLOBAL_REF(CWinSystemAllwinnerGLESContext, g_Windowing);
+#define g_Windowing XBMC_GLOBAL_USE(CWinSystemAllwinnerGLESContext)
diff -Nur a/xbmc/windowing/aw/WinSystemAllwinner.h b/xbmc/windowing/aw/WinSystemAllwinner.h
--- a/xbmc/windowing/aw/WinSystemAllwinner.h	1970-01-01 01:00:00.000000000 +0100
+++ b/xbmc/windowing/aw/WinSystemAllwinner.h	2018-04-08 18:55:39.961814157 +0200
@@ -0,0 +1,71 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "rendering/gles/RenderSystemGLES.h"
+#include "threads/CriticalSection.h"
+#include "windowing/WinSystem.h"
+#include "threads/SystemClock.h"
+#include <FBDEV/eglplatform.h>
+#include <FBDEV/egl.h>
+
+class IDispResource;
+
+class CWinSystemAllwinner : public CWinSystemBase
+{
+public:
+  CWinSystemAllwinner();
+  virtual ~CWinSystemAllwinner();
+
+  bool InitWindowSystem() override;
+  bool DestroyWindowSystem() override;
+
+  bool CreateNewWindow(const std::string& name,
+                       bool fullScreen,
+                       RESOLUTION_INFO& res) override;
+
+  bool DestroyWindow() override;
+  void UpdateResolutions() override;
+
+  bool Hide() override;
+  bool Show(bool show = true) override;
+  virtual void Register(IDispResource *resource);
+  virtual void Unregister(IDispResource *resource);
+private:
+  void SetFramebufferResolution(const RESOLUTION_INFO &res) const;
+  void SetFramebufferResolution(int width, int height) const;
+  bool GetNativeResolution(RESOLUTION_INFO *res) const;
+protected:
+  std::string m_framebuffer_name;
+  EGLDisplay m_nativeDisplay;
+  EGLNativeWindowType m_nativeWindow;
+
+  int m_displayWidth;
+  int m_displayHeight;
+
+  RENDER_STEREO_MODE m_stereo_mode;
+
+  bool m_delayDispReset;
+  XbmcThreads::EndTime m_dispResetTimer;
+
+  CCriticalSection m_resourceSection;
+  std::vector<IDispResource*> m_resources;
+};
diff -Nur a/xbmc/windowing/CMakeLists.txt b/xbmc/windowing/CMakeLists.txt
--- a/xbmc/windowing/CMakeLists.txt	2018-04-01 00:19:02.000000000 +0200
+++ b/xbmc/windowing/CMakeLists.txt	2018-04-08 16:50:46.124059595 +0200
@@ -7,7 +7,7 @@
             XBMC_events.h
             VideoSync.h)
 
-if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR CORE_PLATFORM_NAME_LC STREQUAL aml)
+if(CORE_PLATFORM_NAME_LC STREQUAL rbpi OR CORE_PLATFORM_NAME_LC STREQUAL gbm OR CORE_PLATFORM_NAME_LC STREQUAL aml OR CORE_PLATFORM_NAME_LC STREQUAL aw)
   list(APPEND SOURCES WinEventsLinux.cpp)
   list(APPEND HEADERS WinEventsLinux.h)
 endif()
